{
  "name": "lazy.js",
  "description": "Like Underscore, but lazier",
  "version": "0.3.2",
  "homepage": "http://dtao.github.io/lazy.js/",
  "author": {
    "name": "Dan Tao",
    "email": "daniel.tao@gmail.com",
    "url": "http://philosopherdeveloper.com"
  },
  "main": "lazy.node.js",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/dtao/lazy.js.git"
  },
  "bugs": {
    "url": "https://github.com/dtao/lazy.js/issues"
  },
  "keywords": [
    "lazy",
    "functional",
    "performance",
    "speed",
    "util"
  ],
  "devDependencies": {
    "autodoc": ">= 0.5.5",
    "deft": ">= 0.2.0",
    "jasmine-node": "1.7.x",
    "jsdoc": "3.2.x",
    "JSONStream": ">= 0.7.1",
    "memorystream": ">= 0.2.0",
    "benchmark": "1.0.0",
    "race.js": "0.1.4",
    "lodash": "2.0.0",
    "underscore": "1.5.2",
    "string-table": "0.1.2"
  },
  "scripts": {
    "test": "autodoc -t lazy.js && jasmine-node spec/node_spec.js"
  },
  "readme": "Like Underscore, but lazier\n===========================\n\n[![Build Status](https://travis-ci.org/dtao/lazy.js.png?branch=master)](https://travis-ci.org/dtao/lazy.js)\n[![Bower version](https://badge.fury.io/bo/lazy.js.png)](http://badge.fury.io/bo/lazy.js)\n[![NPM version](https://badge.fury.io/js/lazy.js.png)](http://badge.fury.io/js/lazy.js)\n\n**Lazy.js** it a utility library for JavaScript, similar to [Underscore](http://underscorejs.org/) and [Lo-Dash](http://lodash.com/) but with one important difference: **lazy evaluation** (also known as deferred execution). This can translate to superior performance in many cases, *especially* when dealing with large arrays and/or \"chaining\" together multiple methods. For simple cases (`map`, `filter`, etc.) on small arrays, Lazy's performance should be similar to Underscore or Lo-Dash.\n\nThe following chart illustrates the performance of Lazy.js versus Underscore and Lo-Dash for several common operations using arrays with 10 elements each on Chrome:\n\n![Lazy.js versus Underscore/Lo-Dash](http://i.imgur.com/9vP6sVG.png)\n\nYou can see that the performance difference becomes much more significant for methods that don't require iterating an entire collection (e.g., `indexOf`, `take`) as the arrays get larger:\n\n![Lazy.js versus Underscore/Lo-Dash](http://i.imgur.com/oGPlPug.png)\n\nIntrigued? Great! Lazy.js has no external dependencies, so you can get started right away with:\n\n```html\n<script type=\"text/javascript\" src=\"lazy.js\"></script>\n\n<!-- optional: if you want support for DOM event and AJAX-based sequences: -->\n<script type=\"text/javascript\" src=\"lazy.browser.js\"></script>\n```\n\nOr, if you're using Node.js:\n\n```bash\nnpm install lazy.js\n```\n\nNow let's look at what you can do with Lazy.js. (For more thorough information, take a look at the [API Docs](http://dtao.github.io/lazy.js/docs/).)\n\nIntroduction\n------------\n\nWe'll start with an array containing 1000 integers. Incidentally, generating such an array using Lazy.js is quite trivial:\n\n```javascript\nvar array = Lazy.range(1000).toArray();\n```\n\nNote the `toArray` call; without it, what you'll get from `Lazy.range` won't be an actual *array* but rather a `Lazy.Sequence` object, which you can iterate over using `each`. But we'll get to that in a moment.\n\nNow let's say we want to take the *squares* of each of these numbers, increment them, and then take the first five even results. We'll use these helper functions, to keep the code concise:\n\n```javascript\nfunction square(x) { return x * x; }\nfunction inc(x) { return x + 1; }\nfunction isEven(x) { return x % 2 === 0; }\n```\n\nYes, this is admittedly a very arbitrary goal. (Later I'll get around to thinking of a more realistic scenario.) Anyway, here's one way you might accomplish it using Underscore and its convenient `chain` method:\n\n```javascript\nvar result = _.chain(array).map(square).map(inc).filter(isEven).take(5).value();\n```\n\nThis query does a lot of stuff:\n\n- `map(square)`: iterates over the array and creates a new 1000-element array\n- `map(inc)`: iterates over the new array, creating *another* new 1000-element array\n- `filter(isEven)`: iterates over *that* array, creating yet *another* new (500-element) array\n- `take(5)`: all that just for 5 elements!\n\nSo if performance and/or efficiency were a concern for you, you would probably *not* do things that way using Underscore. Instead, you'd likely go the procedural route:\n\n```javascript\nvar results = [];\nfor (var i = 0; i < array.length; ++i) {\n  var value = (array[i] * array[i]) + 1;\n  if (value % 2 === 0) {\n    results.push(value);\n    if (results.length === 5) {\n      break;\n    }\n  }\n}\n```\n\nThere&mdash;now we haven't created any extraneous arrays, and we did all of the work in one iteration. Any problems?\n\nWell, yeah. The main problem is that this is one-off code, which isn't reusable and took a bit of time to write. If only we could somehow leverage the expressive power of Underscore but still get the performance of the hand-written procedural solution...\n\n***\n\nThat's where Lazy.js comes in! Here's how we'd write the above query using Lazy.js:\n\n```javascript\nvar result = Lazy(array).map(square).map(inc).filter(isEven).take(5);\n```\n\nLooks almost identical, right? That's the idea: Lazy.js aims to be completely familiar to experienced JavaScript devs. Every method from Underscore should have the same name and identical behavior in Lazy.js, except that instead of returning a fully-populated array on every call, it creates a *sequence* object with an `each` method.\n\nWhat's important here is that **no iteration takes place until you call `each`**, and **no intermediate arrays are created**. Essentially Lazy.js combines all query operations into a sequence that behaves quite a bit like the procedural code we wrote a moment ago.\n\nOf course, *unlike* the procedural approach, Lazy.js lets you keep your code clean and functional, and focus on buliding an application instead of optimizing array traversals.\n\nFeatures\n--------\n\nOK, cool. What else can Lazy.js do?\n\n### Indefinite sequence generation\n\nThe sequence-based paradigm of Lazy.js lets you do some pretty cool things that simply aren't possible with Underscore's array-based approach. One of these is the generation of **indefinite sequences**, which can go on forever, yet still support all of Lazy's built-in mapping and filtering capablities.\n\nWant an example? Sure thing! Let's say we want 300 unique random numbers between 1 and 1000.\n\n```javascript\nvar uniqueRandsFrom1To1000 = Lazy.generate(function() { return Math.random(); })\n  .map(function(e) { return Math.floor(e * 1000) + 1; })\n  .uniq()\n  .take(300);\n\n// Output: see for yourself!\nuniqueRandsFrom1To1000.each(function(e) { console.log(e); });\n```\n\nPretty neat. How about a slightly more advanced example? Let's use Lazy.js to make a [Fibonacci sequence](http://en.wikipedia.org/wiki/Fibonacci_number).\n\n```javascript\nvar fibonacci = Lazy.generate(function() {\n  var x = 1,\n      y = 1;\n  return function() {\n    var prev = x;\n    x = y;\n    y += prev;\n    return prev;\n  };\n}());\n\n// Output: undefined\nvar length = fibonacci.length();\n\n// Output: [2, 2, 3, 4, 6, 9, 14, 22, 35, 56]\nvar firstTenFibsPlusOne = fibonacci.map(inc).take(10).toArray();\n```\n\nOK, what else?\n\n### Asynchronous iteration\n\nYou've probably [seen code snippets before](https://gist.github.com/dtao/2351944) that show how to iterate over an array asynchronously in JavaScript. But have you seen an example packed full of map-y, filter-y goodness like this?\n\n```javascript\nvar asyncSequence = Lazy(array)\n  .async(100) // specifies a 100-millisecond interval between each element\n  .map(inc)\n  .filter(isEven)\n  .take(20);\n\n// This function returns immediately and begins iterating over the sequence asynchronously.\nasyncSequence.each(function(e) {\n  console.log(new Date().getMilliseconds() + \": \" + e);\n});\n```\n\nAll right... what else?\n\n### Event sequences\n\nWith indefinite sequences, we saw that unlike Underscore and Lo-Dash, Lazy.js doesn't actually need an in-memory collection to iterate over. And asynchronous sequences demonstrate that it also doesn't need to do all its iteration at once.\n\nNow here's a really cool combination of these two features: with a small extension to Lazy.js (lazy.browser.js, a separate file to include in browser-based environments), you can apply all of the power of Lazy.js to **handling DOM events**. In other words, Lazy.js lets you think of DOM events as a *sequence*&mdash;just like any other&mdash;and apply the usual `map`, `filter`, etc. functions on that sequence.\n\nHere's an example. Let's say we want to handle all `mousemove` events on a given DOM element, and show their coordinates in one of two other DOM elements depending on location.\n\n```javascript\n// First we define our \"sequence\" of events.\nvar mouseEvents = Lazy(sourceElement).on(\"mousemove\");\n\n// Map the Event objects to their coordinates, relative to the element.\nvar coordinates = mouseEvents.map(function(e) {\n  var elementRect = sourceElement.getBoundingClientRect();\n  return [\n    Math.floor(e.clientX - elementRect.left),\n    Math.floor(e.clientY - elementRect.top)\n  ];\n});\n\n// For mouse events on one side of the element, display the coordinates in one place.\ncoordinates\n  .filter(function(pos) { return pos[0] < sourceElement.clientWidth / 2; })\n  .each(function(pos) { displayCoordinates(leftElement, pos); });\n\n// For those on the other side, display them in a different place.\ncoordinates\n  .filter(function(pos) { return pos[0] > sourceElement.clientWidth / 2; })\n  .each(function(pos) { displayCoordinates(rightElement, pos); });\n```\n\nAnything else? Of course!\n\n### String processing\n\nNow here's something you may not have even thought of: `String.match` and `String.split`. In JavaScript, each of these methods returns an *array* of substrings. If you think about it, this often means doing more work than necessary; but it's the quickest way (from a developer's standpoint) to get the job done.\n\nFor example, suppose you wanted the first five lines of a block of text. You could always do this:\n\n```javascript\nvar firstFiveLines = text.split(\"\\n\").slice(0, 5);\n```\n\nBut of course, this actually splits *the entire string* into every single line. If the string is very large, this is quite wasteful.\n\nWith Lazy.js, we don't need to split up an entire string just to treat it as a sequence of lines. We can get the same effect by wrapping the string with `Lazy` and calling `split`:\n\n```javascript\nvar firstFiveLines = Lazy(text).split(\"\\n\").take(5);\n```\n\nThis way we can read the first five lines of an arbitrarily large string (without pre-populating a huge array) and map/reduce on it just as with any other sequence.\n\nSimilarly with `String.match`: let's say we wanted to find the first 5 alphanumeric matches in a string. With Lazy.js, it's easy!\n\n```javascript\nvar firstFiveWords = Lazy(text).match(/[a-z0-9]+/i).take(5);\n```\n\nPiece of cake.\n\n### Stream processing\n\nLazy.js can wrap *streams* in Node.js as well.\n\nGiven any [`Readable Stream`](http://nodejs.org/api/stream.html#stream_class_stream_readable), you can wrap it with `Lazy` just as with arrays:\n\n```javascript\nLazy(stream)\n  .take(5) // Read just the first 5 chunks of data read into the buffer.\n  .each(processData);\n```\n\nFor convenience, specialized helper methods for dealing with either file streams or HTTP streams are also offered. (**Note: this API will probably change.**)\n\n```javascript\n// Read the first 5 lines from a file:\nLazy.readFile(\"path/to/file\")\n  .lines()\n  .take(5)\n  .each(doSomething);\n\n// Read lines 5-10 from an HTTP response.\nLazy.makeHttpRequest(\"http://example.com\")\n  .lines()\n  .drop(5)\n  .take(5)\n  .each(doSomething);\n```\n\nIn each case, the elements in the sequence will be \"chunks\" of data most likely comprising multiple lines. The `lines()` method splits each chunk into lines (lazily, of course).\n\n***\n\n**This library is experimental and still a work in progress.**\n",
  "readmeFilename": "README.md",
  "_id": "lazy.js@0.3.2",
  "_shasum": "7cc1107e5f809ae70498f511dd180e1f80b4efa9",
  "_from": "lazy.js@~0.3.2",
  "_resolved": "https://registry.npmjs.org/lazy.js/-/lazy.js-0.3.2.tgz"
}
